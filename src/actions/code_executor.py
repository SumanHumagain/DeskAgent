"""
Code Executor - META-PRIMITIVE for dynamic code execution
OpenAI generates code based on user intent, we execute it
"""

import sys
import io
import json
import subprocess
from contextlib import redirect_stdout, redirect_stderr
from typing import Dict, Any
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.admin_elevation import AdminElevation, is_admin


class CodeExecutor:
    """
    Execute dynamically generated code from OpenAI
    This is a meta-primitive that enables infinite flexibility
    """

    def run_python_code(self, code: str, description: str = None) -> Any:
        """
        Execute Python code dynamically generated by OpenAI

        Args:
            code: Python code to execute
            description: Human-readable description

        Returns:
            Result of code execution (prints, return values, etc.)
        """
        print(f"[CODE EXECUTOR] Executing: {description or 'dynamic code'}", file=sys.stderr)
        print(f"[CODE EXECUTOR] Code:\n{code}", file=sys.stderr)

        try:
            # Capture stdout and stderr
            stdout_capture = io.StringIO()
            stderr_capture = io.StringIO()

            # Create execution namespace with useful imports pre-loaded
            namespace = {
                '__builtins__': __builtins__,
                'print': print,
                'json': json,
            }

            # Execute the code
            with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                exec(code, namespace)

            # Get captured output
            stdout_output = stdout_capture.getvalue()
            stderr_output = stderr_capture.getvalue()

            # Check if code defined a 'result' variable (common pattern)
            result = namespace.get('result', None)

            # Combine all outputs
            if result is not None:
                output = result
            elif stdout_output:
                output = stdout_output.strip()
            else:
                output = "Code executed successfully (no output)"

            print(f"[CODE EXECUTOR] ✓ Result: {output}", file=sys.stderr)

            if stderr_output:
                print(f"[CODE EXECUTOR] Stderr: {stderr_output}", file=sys.stderr)

            return output

        except Exception as e:
            error_msg = f"Code execution failed: {str(e)}"
            print(f"[CODE EXECUTOR] ✗ {error_msg}", file=sys.stderr)
            raise Exception(error_msg)

    def run_powershell(self, script: str, description: str = None, require_admin: bool = None) -> str:
        """
        Execute PowerShell script dynamically generated by OpenAI
        WITH AUTOMATIC ADMIN ELEVATION WHEN NEEDED

        Args:
            script: PowerShell script to execute
            description: Human-readable description
            require_admin: If True, force run as admin. If None, auto-detect based on keywords

        Returns:
            Output from PowerShell execution
        """
        print(f"[POWERSHELL] Executing: {description or 'dynamic script'}", file=sys.stderr)
        print(f"[POWERSHELL] Script:\n{script[:200]}{'...' if len(script) > 200 else ''}", file=sys.stderr)

        # Auto-detect if admin is needed based on keywords
        if require_admin is None:
            admin_keywords = [
                'firewall', 'defender', 'netsh', 'set-netfirewallprofile',
                'bluetooth', 'new-netfirewallrule', 'remove-netfirewallrule',
                'set-service', 'start-service', 'stop-service',
                'set-itemProperty', 'HKLM:', 'registry',
                'net user', 'net localgroup', 'secpol.msc'
            ]
            require_admin = any(keyword.lower() in script.lower() for keyword in admin_keywords)

        # Check if we're running as admin
        running_as_admin = is_admin()

        if require_admin and not running_as_admin:
            print(f"[POWERSHELL] ⚠ Admin privileges required but not available", file=sys.stderr)
            print(f"[POWERSHELL] Attempting to execute with elevation...", file=sys.stderr)

            # Use AdminElevation to run with admin rights
            success, stdout, stderr = AdminElevation.run_powershell_as_admin(script, wait=True)

            if not success:
                error_msg = f"PowerShell execution failed (admin elevation): {stderr or 'Unknown error'}"
                print(f"[POWERSHELL] ✗ {error_msg}", file=sys.stderr)
                raise Exception(error_msg)

            output = stdout.strip() or "PowerShell executed successfully with admin elevation (no output)"
            print(f"[POWERSHELL] ✓ Output (admin): {output[:200]}{'...' if len(output) > 200 else ''}", file=sys.stderr)

            return output

        # Normal execution (either admin not needed or already running as admin)
        try:
            print(f"[POWERSHELL] Running {'with admin privileges' if running_as_admin else 'without admin privileges'}", file=sys.stderr)

            # Execute PowerShell command
            result = subprocess.run(
                ['powershell', '-Command', script],
                capture_output=True,
                text=True,
                timeout=60,  # 60 second timeout for safety
                shell=False,
                creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0
            )

            stdout_output = result.stdout.strip()
            stderr_output = result.stderr.strip()

            if result.returncode != 0:
                error_msg = f"PowerShell failed (exit code {result.returncode}): {stderr_output or 'Unknown error'}"
                print(f"[POWERSHELL] ✗ {error_msg}", file=sys.stderr)

                # If failed and admin might help, suggest it
                if not running_as_admin and 'access denied' in stderr_output.lower():
                    error_msg += "\n[HINT] This operation may require administrator privileges. Please run the application as Administrator."

                raise Exception(error_msg)

            output = stdout_output or "PowerShell executed successfully (no output)"

            print(f"[POWERSHELL] ✓ Output: {output[:200]}{'...' if len(output) > 200 else ''}", file=sys.stderr)

            if stderr_output:
                print(f"[POWERSHELL] Warning: {stderr_output}", file=sys.stderr)

            return output

        except subprocess.TimeoutExpired:
            error_msg = "PowerShell execution timed out (60s limit)"
            print(f"[POWERSHELL] ✗ {error_msg}", file=sys.stderr)
            raise Exception(error_msg)

        except Exception as e:
            error_msg = f"PowerShell execution failed: {str(e)}"
            print(f"[POWERSHELL] ✗ {error_msg}", file=sys.stderr)
            raise Exception(error_msg)
